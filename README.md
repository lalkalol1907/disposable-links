# Url shortener
Проект написан как тестовое задание с целью продемонстрировать базовые навыки в Nest
Что использовано:
- NestJS
- TypeScript
- ESLint
- Prettier
- Redis
- Jest
- Docker
- Docker-compose

### Что сделано:
- Реализована логика создания и получения ссылок
- Реализовано хранение в Redis
- Написаны Unit-тесты для сервиса
- Написаны интеграционные тесты
- Показана работа с динамическими модулями
- Показана работа с конфигами (.env файл и просто переменные окружения в зависимости от среды запуска)
- Сделана валидация переменных конфигурации
- Показана работа с моками
- Показана работа с Swagger в NestJs
- Показана работа с ValidationPipe
- Показана работа с Dockerfile, в том числе с builder
- Показана работа с docker-compose, в том числе networks

### Что не доделано:
- Неполное покрытие Unit тестами
- Неполное покрытие всех сценариев e2e тестами
- Не описаны все метаданные запросов в Swagger
- Не описаны ответы с ошибкой в Swagger
- Не сделан кастомный ExceptionFilter (не вижу смысла натягивать его на глобус)

## Принцип работы
При запросе POST /create-shorten-link генерируется короткая одноразовая ссылка (uuid v4 без знаков тире) и записывается в Redis, после чего отправляется ответом на запрос.
При запросе GET /:url из Redis получается оригинальная ссылка и удаляется из него (так как ссылка должна быть одноразовая по условию) и отправляется пользователю ответом на запрос
При попытке получить несуществующую ссылку возвращается 404

## Возможные вопросы:
> Возможна ли коллизия?
>>В теории да, но ее шанс слишком мал, вероятность описана на википедии:  
>>> Only after generating 1 billion UUIDs every second for the next 100 years, the probability of creating just one duplicate would be about 50%. Or, to put it another way, the probability of one duplicate would be about 50% if every person on earth owned 600 million UUIDs.
> 
> Что можно сделать с возможной коллизией?
>> Проверять нет ли данного ключа в базе. Тогда тоже можно подумать о вероятности вхождения в бесконечный цикл, если будет такое, что каждый раз генерируются существующие значения. Вероятность этого, конечно, тоже стремится к нулю
> 
>> Склеить 2 uuid, тем самым вероятность возведется в квадрат и станет еще ближе к нулю, но тоже не вижу в этом смысла 
>
> Почему Redis? 
>> Объем данных мал, ссылки хранятся недолго, для ускорения работы можно себе позволить использовать его вместо NoSQL или SQL баз данных
